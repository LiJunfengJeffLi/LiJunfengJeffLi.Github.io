<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mysql学习笔记（十）——创建和操纵表]]></title>
    <url>%2F2017%2F11%2F24%2Fmysql-10%2F</url>
    <content type="text"><![CDATA[本章节介绍表的创建、更改和删除的基本知识。Mysql不仅用于表数据操纵，而且还可以用来执行数据库和表的所有操作，包括表本身的创建和处理。一般有两种创建表的方法：一种是使用具有交互式创建和管理表的工具（例如Workbench一类的客户机软件）；另一种是直接用Mysql语句操纵（为了创建表可使用SQL的create table工具）。 1. 创建表1.1 表创建基础 为利用create table创建表，必须给出下列信息： 新表的名字，在关键字create table之后给出； 表列的名字和定义，用逗号分隔。 create table语句也可能会包含其他关键字或选项，但至少要包括表的名字和列的细节。下例的Mysql语句用于创建customers表： 12345678910111213create table customers #输入( cust_id int not null anto_increment, cust_name char(50) not null, cust_address char(50) null, cust_city char(50) null, cust_state char(5) null, cust_zip char(10) null, cust_country char(50) null, cust_contact char(50) null, cust_email char(255) null, primary key (cust_id))engine=innodb； 上例语句中，表名紧跟在create table关键字之后。实际的表定义（各个列）括在圆括号之中，各列之间用逗号分隔。这个表由9个列组成，每列的定义以列名（在表中唯一）开始，后跟列的数据类型以及允许空值与否（NULL(默认)/NOT NULL）。表的主键可以在创建表时用primary key关键字指定（此例中指定cust_id列为主键）。 注意，在创建新表时，指定的表名必须不存在，否则将会出错。如果仅想在表不存在时创建它，可以在表名之后给出if not exists，这样做并不会检查已有表的模式和打算创建表的模式（表的布局和特性信息）是否匹配，而是只检查表名是否存在，在表名不存在时创建该表。 1.2 主键再介绍 必须知道，主键值必须唯一。即，表中的每个行必须具有唯一的主键值。如果主键使用单个列(如上例)，则它的值必须唯一；如果使用多个列（如下例），则这些列的组合值必须唯一。 123456789create table orderitems #输入( order_num int not null, order_item int not null, prod_id char(10) not null, quantity int not null, item_price decimal(8,2) not null, primary key (order_num,order_item))engine=innodb; 为创建多个列组成的主键，应该用逗号分隔的列表给出各列名。orderitems表包含orders表中每个订单的细节，每个订单有多项物品，因此订单号和订单物品的组合是唯一的，从而适合做主键。注意，主键可以再创建表时定义，或者在创建表之后定义。其次，主键中只能使用不允许NULL值的列。 1.3 自动增量 以customers表为例，该表中的顾客由cust_id列唯一标识，每个顾客只有一个唯一编号。这些编号除它们是唯一的之外没有任何意义。在需要新增一个顾客时，就需要一个新的客户ID，它可以是任意的，只要保证是唯一的即可。那么最简单的方法便是使用下一个编号，例如目前最后一个客户为10005，则新插入的客户其ID可以定位10006。而在实际操作中我们或许并不清楚目前最后一个客户ID（当然可以使用select语句检索，但这样做不可靠，因为在多用户应用中无法保证你在检索的同时没有新客户插入）。此时，就需要用auto_increment来完成此任务。 auto_increment告诉Mysql，本列每当增加一行时自动增量。每次执行一个insert操作时，Mysql自动对该列增量，给该列赋予下一个可用的值。这样给每个行分配一个唯一的cust_id，从而可用作主键值。注意，每个表只允许一个auto_increment列，而且它必须被索引（如通过使它成为主键）。如果一个列被指定为自动增量，必要的时候也可以在insert语句中指定一个唯一值，该值可以替代自动生成的值，而后续增将采用此手工插入的值。 使用last_insert_id()这个函数可以获取最后一个自动增量值。 1.4 指定默认值 如果在插入行时没有给出值，Mysql允许指定此时使用的默认值。默认值用create table语句的列定义中的default关键字指定。如下例： 123456789create table orderitems #输入( order_num int not null, order_item int not null, prod_id char(10) not null, quantity int not null default 1, item_price decimal(8,2) not null, primary key (order_num,order_item))engine=innodb; 此例中，quantity列包含订单中每项物品的数量，该列后接default 1指示Mysql，在未给出数量的情况下使用1。与大多数DBMS不同的是，Mysql不允许使用函数作为默认值，它只支持常量。 1.5 引擎类型 迄今为止，使用过的create table语句全都以engine=innodb结束。实际上，Mysql有一个具体管理和处理数据的内部引擎。在使用create table语句时，该引擎具体创建表，而在使用select语句或进行其他数据库处理时，该引擎在内部具体处理你的请求。与其他DBMS不同的是Mysql具有多种引擎，这些引擎全都隐藏在Mysql服务器内，全都能执行create table和select等命令。 对于不同的引擎，它们各自具有不同的功能和特性，为不同任务选择正确的引擎能获得良好的功能和灵活性。以下是几个常用引擎： InnoDB：一个可靠的事务处理引擎，但不支持全文本搜索。 MyISAM：一个性能极高的引擎，它支持全文本搜索，但不支持事物处理。 MEMORY：在功能上等同于MyISAM，但由于数据存储在内存中，速度很快（适合于临时表）。 引擎类型可以混用。但要注意，外键不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎表的外键。Mysql所支持引擎的完整列表（及它们之间的不同），请参阅http://dev.mysql.com/doc/refman/5.0/en/storage_engines.html。 2. 更新和删除表 为更新表定义，可以使用alter table语句。但在理想状态下，当表中存储数据以后，该表就不应该再被更新（在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动）。为了使用alter table更改表结构，必须给两种信息：一是表名；二是所作出的更改。如下例： 12alter table vendors #给vendors表添加一个名为vend_phone的列，必须明确其数据类型add vend_phone char(20); 12alter table vendors #删除刚刚添加的列drop column vend_phone; 123alter table orders #定义外键add constraint fk_products_customersforeign key (cust_id) references customers (cust_id); 注意，一定要小心使用alter table，应该在进行改动之前做一个完整的备份（包括模式和数据）。 删除表非常简单，使用drop table即可，如:drop table customers2;。表的重命名使用rename table语句，如rename table customers1 to customers2;。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（九）——插入、更新和删除数据]]></title>
    <url>%2F2017%2F11%2F23%2Fmysql-9%2F</url>
    <content type="text"><![CDATA[SQL除最常用的select语句(检索)外，还有三个经常使用SQL语句：insert（插入）、update（更新）和delete（删除）。它们的作用是操纵数据库表数据，而与select语句不同的是这些语句在使用时有一定的危险性，通常都需要对它们进行一定的限制，以保证数据的安全。 1. 插入数据 顾名思义，insert是用来插入行到数据库表的。插入可以用以下几种方式使用： 插入完整的行； 插入行的一部分； 插入多行； 插入某些查询的结果。 从数据安全方面考虑，可针对每个表或每个用户，利用Mysql的安全机制（后续介绍）禁止使用insert语句。 1.1 插入完整的行 把数据插入表中的最简单方法是使用基本的INSERT语法，它要求指定表名和被插入到新行中的值。如下例： 12345678910111213141516insert into customers(cust_name, #输入cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)values('Pep E. LawPew','100 Main Street','Los Angeles','CA','90046','USA'NULL,NULL); 注意，此例插入一个新客户到customers表，存储到每个表列中的数据在values子句中给出。每个列必须提供一个值，如果某个列没有值，必须使用NULL值（在对应列允许使用空值的条件下）。在插入行时，Mysql将用values列表中相应的值填入列表中的对应项（不一定是实际表列的顺序但要按照values前指定的顺序）。其次，由于cust_id列由于在创建表时指定为自动增量，因此不必给出它对应的新值（这是Mysql的工作）。insert语句一般不会产生输出。 如果表的定义允许，则可以在insert操作中省略某些列（如该例中的cust_id）。省略的列必须满足以下某个条件。 该列定义为允许NULL值（空值）； 在表定义中给出默认值。这表示如果不给出值，将使用默认值（自动增量也属于该类）。 若在不满足上述两种条件的情况下，使用values语句时省略该列，则Mysql将产生一条错误信息，并且相应的行插入不成功。 1.2 插入多个行 当然可以使用多条insert语句，但如果每条insert语句中的列名和次序相同，可以如下组合语句： 1234567891011121314151617181920212223insert into customers(cust_name, #输入cust_address,cust_city,cust_state,cust_zip,cust_country,)values( 'Pep E. LawPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA' ), ( 'M. Martian', '42 Galaxy Way', 'New York', 'NY', '11213', 'USA' ); 其中单条INSERT语句有多组值，每组值用一对圆括号括起来并用逗号分隔。此语句可以提高数据库处理的性能，因为Mysql用单条insert语句处理多个插入要比使用多条insert语句快。 1.3 插入检索出的数据 INSERT一般用来给表插入一个指定列值的行。但是，INSERT还是存在另一种形式，可以利用它将一条select语句的结果插入表中。这就是INSERT SELECT，顾名思义，它是由一条insert语句和一条select语句组成的。假如现在想从custnew表中合并客户到你的customers表，可以按如下操作进行： 12345678910111213141516171819insert into customers(cust_id, #输入cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)select cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_emailfrom custnew; 此例中，select语句从custnew中检索出要插入的值，而不是列出它们。select列出的每个列对应于customers表名后所跟列表中的每个列。这条语句依赖于custnew表中有多少行，如果这个表为空，则没有行被插入（不会产生错误，因为操作依然是合法的）。注意，这个例子中导入了cust_id（假设你能确保cust_id的值不会重复，如果主键值重复，insert操作会失败）。当然也可以简单省略这列，这样Mysql会根据自动增量生产新值。 注意，该语句并不要求列名匹配（虽然在此例中使用了相同的列名），事实上Mysql并不关心select返回的列名，它使用的是列的位置（即select的第n列用来填充insert指定列表中的第n列）。其次,INSERT SELECT中的select语句也可以使用where子句过滤要插入的数据。 2. 更新和删除数据2.1 更新数据 要更新（修改）表中的数据，可使用update语句。可采用两种方式使用该语句：更新表中特定的行；更新表中所有的行。update语句由三部分组成，分别是：要更新的表、列名和它们的新值、确定要更新行的过滤条件。如下例： 1234update customers #输入set cust_name = 'The Fudds', cust_email = 'elmer@fudd.com'where cust_id = 10005; 该例更新了客户10005的客户名和电子邮件地址。update语句总是以要更新的表的名字开始，此例中要更新的表的名字为custmoers。set命令用来将新值赋给被更新的列（如该例，更新多个列只需使用单个set命令，用逗号分隔），update语句以where子句结束，它告诉Mysql更新哪一行（应该总是给出where子句，否则Mysql将用此新值更新所有行）。注意，update语句可以使用子查询。为了删除某行中一列的值，可设置它为NULL。 如果使用update语句更新多行，并且在更新这些行中的某行时发生错误，则整个操作将被取消，错误发生前更新的所有行业恢复到原来的值。如果想在发生错误时保持继续更新，可以使用ignore关键字，如update ignore customers...。 2.2 删除数据 要删除一个表中的数据，可以使用delete语句。可以用两种方式使用该语句：从表中删除特定的行；从表中删除所有的行。如下例： 12delete from customers #输入where cust_id = 10006; 上述语句中，delete from要求指定从中删除数据的表名，where子句过滤要删除的行（如果省略where子句将删除表中所有的行）。注意，delete语句不需要列名和通配符，它删除整行而不是整列，要删除整列需要使用update语句。其次,注意delete语句的作用是删除表中的数据而不是删除表本身。 如果想删除表中的所有行，truncate table语句也可以完成相同的工作，且它比delete语句速度更快（因为它通过删除原来的表并重建一个表来完成，不需要逐行删除表中数据）。 注意，在对更新和删除语句使用where子句之前，可以先用select语句进行测试以确保过滤的记录正确。使用强制实施引用完成性（它通过在表定义时指定主键和外键来实现，后续学习中会涉及到）的数据库，这样Mysql将不允许删除具有与其他表相关联的数据的行。其次，Mysql中没有撤销按钮，应该非常小心使用update和delete。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（八）——联结表]]></title>
    <url>%2F2017%2F11%2F22%2Fmysql-8%2F</url>
    <content type="text"><![CDATA[SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表，联结是利用SQL的SELECT能执行的最重要的操作。通过前面的章节我们知道，分解数据为多个表能更有效地存储及处理数据，且具有更大的可伸缩性（能够适应不断增加的工作量而不失败）。与此对应的代价是常规的单条SELECT语句难以同时对多个表进行检索。而使用联结可以解决这一问题。 联结是一种机制，用来在一条SELECT语句中关联表。使用特殊的语法，可以联结多个表并返回一组输出。要注意的是，联结并不是实体（即它在实际的数据库表中并不存在），它由Mysql根据需要建立（存在于查询的执行中）。 什么是关系表？ 在能够有效的使用联结之前，必须了解关系表以及关系数据库设计的一些基础知识。首先来思考一个例子，假如有一个包含产品目录的数据库表，其中每个类别产品各占一行。对于每种产品，要存储的信息包括产品描述、价格和该产品的供应商信息（供应商名、地址、联系电话等）。那么如何合理存储这些信息呢？要注意，往往一个供应商会生产多种产品。我们当然可以将它们存储在一张表中，但这样会带来一些问题：对于同一个供应商生产的产品后接的供应商信息相同，而重复信息耗费空间又耗时；如果供应商信息改变，需要进行多处改动。 因此，将数据进行有效分解并存储是很有必要的，这也是关系数据库设计基础。一类数据一个表，而各个表通过某些常用值（关系(relational)）互相关联。在本例中，可以建立两个表，一个存储产品信息（products表），一个存储供应商信息（vendors表）。vendors表以供应商ID作为主键，而products表除供应商ID之外不存储其他供应商信息。vendors表的主键又叫做products表的外键（供应商ID），它将两表关联，利用供应商ID可以从vendors表中检索出供应商相关信息。 外键（foreign key）：外键是某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。 这样做的好处是：供应商信息不重复；如果供应商信息变动，只需更新vendors表中的单个记录，而相关表中的数据不用改动。总之，关系数据可以有效存储和方便处理，它的可伸缩性远比非关系数据库要好。 1. 创建联结 首先来看下面这个例子： 1234567891011121314151617181920212223select vend_name, prod_name, prod_price #输入from vendors, productswhere vendors.vend_id = products.vend_idorder by vend_name, prod_name;+-------------+----------------+------------+ #输出| vend_name | prod_name | prod_price |+-------------+----------------+------------+| ACME | Bird seed | 10.00 || ACME | Carrots | 2.50 || ACME | Detonator | 13.00 || ACME | Safe | 50.00 || ACME | Sling | 4.49 || ACME | TNT (1 stick) | 2.50 || ACME | TNT (5 sticks) | 10.00 || Anvils R Us | .5 ton anvil | 5.99 || Anvils R Us | 1 ton anvil | 9.99 || Anvils R Us | 2 ton anvil | 14.99 || Jet Set | JetPack 1000 | 35.00 || Jet Set | JetPack 2000 | 55.00 || LT Supplies | Fuses | 3.42 || LT Supplies | Oil can | 8.99 |+-------------+----------------+------------+14 rows in set (0.05 sec) 上述语句中，select指定了三个列，与以前不同的是它们分别存储在两张表中，而from关键字后也接相应的两张表。where子句则给出了两张表的正确联结，它指示Mysql匹配vendors表中vend_id和products表中的vend_id（通过完全限定列名的方式）。 注意，各位看官或许会对利用where子句建立联结关系感到疑惑。实际上，要知道在一条select语句中联结几个表时，相应的关系是在运行中构造的（在数据库表的定义中不存在能指示Mysql对表进行联结的东西），即必须由我们自己完成。联结表时，实际上是将两个表的相关列进行配对（满足联结条件），类似过滤条件结果只输出满足匹配条件的行。如果不给出where子句，第一个表中每行将与第二个表的每行进行配对，而不管它们逻辑上是否可以配在一起（将返回一个笛卡尔积）。因此，应该保证所有的联结都有where子句及其正确性。 1.1 内部联结 前述所用联结称为等值联结（equijion），它基于两个表之间的相等测试。这种联结也称为内部联结，它也可以使用稍微不同的语法来明确指定联结的类型。如下例： 123select vend_name, prod_name, prod_price #输入from vendors inner join productson vendors.vend_id = products.vend_id; 此语句与前一例语句的输出完全一致，有所不同的是该语句中from子句的内容略有不同。这里，两个表之间的关系是from子句的组成部分，并以inner join指定。且在使用这种语法时，联结条件用特定的on子句而不是where子句给出，传递给ON的实际条件与传递给WHERE的相同（SQL规范首选INNER JOIN语法）。 1.2 联结多个表 SQL对一条select语句中可以联结的表的数目没有限制。创建联结的基本规则也相同，首先列出所有表，然后定义表之间的关系。如下例： 1234567891011121314select prod_name, vend_name, prod_price, quantity #输入from orderitems, products, vendorswhere products.vend_id = vendors.vend_idand orderitems.prod_id = products.prod_idand order_num = 20005;+----------------+-------------+------------+----------+ #输出| prod_name | vend_name | prod_price | quantity |+----------------+-------------+------------+----------+| .5 ton anvil | Anvils R Us | 5.99 | 10 || 1 ton anvil | Anvils R Us | 9.99 | 3 || TNT (5 sticks) | ACME | 10.00 | 5 || Bird seed | ACME | 10.00 | 1 |+----------------+-------------+------------+----------+4 rows in set (0.05 sec) 此例子显示编号为20005的订单中的产品。订单物品存储在orderitems表中。每个产品按其产品ID存储，它引用products表中的产品，这些产品通过供应商ID联结到vendors表中相应的供应商，供应商ID存储在每个产品的记录中。这里from子句列出了3个表，而where子句定义了这两个联结条件，而第三个联结条件用来过滤出订单20005中的物品。 2. 创建高级联结 除了前面使用的简单联结（内部联结或等值联结）外，还有其他高级联结：自联结、自然联结、外部联结。 如何使用表别名？ 之前我们学过如何使用别名引用被检索的表列，实际上，别名除了用于列名和计算字段外，SQL还允许给表起别名。这样做的好处首先是可以简化SQL语句，其次允许在select语句中多次使用相同的表（见自联结部分）。如下例： 12345select prod_name, vend_name, prod_price, quantity #输入from orderitems as o, products as p, vendors as vwhere p.vend_id = v.vend_idand o.prod_id = p.prod_idand order_num = 20005; 该例完全复制了前一个例子的语句，只是通过使用表别名对其进行了简化。注意该例中，表别名只用于where子句，事实上，它还可以用于select的列表、order by子句等等。表别名只在查询中使用，与列别名不同，它不返回到客户机。 2.1 自联结 首先来看一个例子，假如你发现某物品（ID为DTNTR）存在问题，此时你想知道生产该物品的供应商的其他产品是否也存在问题。要完成这个任务，第一种方法是首先找到生产该物品的供应商，然后再检索出这个供应商生产的其他产品（使用子查询）。第二种方法是使用自联结，如下： 12345678910111213141516select p1.prod_id, p1.prod_name #输入from products as p1, products as p2where p1.vend_id = p2.vend_idand p2.prod_id = 'DTNTR';+---------+----------------+ #输出| prod_id | prod_name |+---------+----------------+| DTNTR | Detonator || FB | Bird seed || FC | Carrots || SAFE | Safe || SLING | Sling || TNT1 | TNT (1 stick) || TNT2 | TNT (5 sticks) |+---------+----------------+7 rows in set (0.04 sec) 此查询中需要的两个表是相同的表，因此在from子句后出现两次，这是合法的，但对products的引用具有二义性。使用表别名可以解决这一问题。 2.2 自然联结 无论何时对表进行联结，应该至少有一个列出现在不止一张表中（被联结的列）。简单的联结返回所有数据，甚至相同的列多次出现。而自然联结排除多次出现，使每个列只返回一次。这一般通过对表使用通配符，对其他表的列使用明确子集来完成。如下例： 123456select c.*, o.order_num, o.order_date, #输入 oi.prod_id, oi.quantity, oi.item_pricefrom customers as c, orders as o, orderitems as oiwhere c.cust_id = o.cust_idand oi.order_num = o.order_numand prod_id = 'FB'; 事实上，我们之前所建立的每个内部联结都是自然联结。 2.3 外部联结 许多联结将一个表中的行与另一个表中的行相关联。但有的行时没有对应的关联行的，我们有时候也希望将这些行包含在我们的查询中。例如，列出所有产品及其订购数量，包括没有人订购的产品。这类工作也需要通过连接来完成，这种类型的联结称之为外部联结。如下例： 12345678910111213141516select customers.cust_id, orders.order_num #输入from customers left outer join orderson customers.cust_id = orders.cust_id;+---------+-----------+ #输出| cust_id | order_num |+---------+-----------+| 10001 | 20005 || 10001 | 20009 || 10002 | NULL || 10003 | 20006 || 10004 | 20007 || 10005 | 20008 || 10006 | NULL || 10007 | NULL |+---------+-----------+8 rows in set (0.01 sec) 上述语句使用了outer join来指定联结类型。与内部联结不同的是，外部联结还包括没有对应关联行的行，因此需要通过left或者right关键字指定需要包括其所有行的表（right指出右边的表，而left指出左边的表）。 2.4 使用带聚集函数的联结 在学习聚集函数时，我们知道它可以用来汇总数据。但之前所有的例子都是从单个表汇总，事实上它们也可以与联结一起使用。比如，需要检索所有客户及每个客户所下订单数： 1234567891011121314select customers.cust_name, customers.cust_id, #输入 count(orders.order_num) as num_ordfrom customers inner join orderson customers.cust_id = orders.cust_idgroup by customers.cust_id;+----------------+---------+---------+ #输出| cust_name | cust_id | num_ord |+----------------+---------+---------+| Coyote Inc. | 10001 | 2 || Wascals | 10003 | 1 || Yosemite Place | 10004 | 1 || E Fudd | 10005 | 1 |+----------------+---------+---------+4 rows in set (0.00 sec) 此select语句使用inner join将customers和orders表互相联结。group by按客户分组数据。因此，函数调用count(orders.order_num)对每个订单计数。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（七）——子查询与组合查询]]></title>
    <url>%2F2017%2F11%2F21%2Fmysql-7%2F</url>
    <content type="text"><![CDATA[查询（query）是任何SQL语句的统称，而此术语一般指SELECT语句。在此章节之前，我们所看到的所有select语句都是简单查询，即从单个数据库表中检索数据的单条语句。实际上，SQL还允许创建子查询（subquery），它是嵌套在其他查询中的查询。此外，Mysql也允许执行多个查询（多条select语句），并将结果作为单个查询结果返回。 1.子查询 子查询（subquery）:嵌套在其他查询中的查询。 1.1 利用子查询进行过滤 假设某一商家将订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各个订单的物品存储在相关的orderitems表中。而orders表不存储客户信息，它只存储在相关的customers表中。现在，商家需要列出订购物品TNT2的所有客户，应该怎么进行检索呢？可分为三个步骤： 检索包含物品TNT2的所有订单编号； 检索具有前一步骤列出的订单编号的所有客户的ID； 检索前一步骤返回的所有客户ID的客户信息。 上述每个步骤都可以单独作为一个查询来执行，即把一条select语句返回的结果用于另一条select语句的where子句。事实上，我们也可以通过使用子查询来讲3个查询组合成一条语句。如下： 1234567891011121314select cust_name, cust_contact #输入from customerswhere cust_id in (select cust_id from orders where order_num in (select order_num from orderitems where prod_id = 'TNT2'));+----------------+--------------+ #输出| cust_name | cust_contact |+----------------+--------------+| Coyote Inc. | Y Lee || Yosemite Place | Y Sam |+----------------+--------------+2 rows in set (0.05 sec) 注意，在select语句中，子查询总是从内向外处理。在处理上面的select语句时，Mysql实际上执行了三个操作，从最里层到最外层。包含子查询的select语句难以阅读和调试，如上述将语句分解为多行并加以适当的缩进可以极大程度上简化子查询的使用。其次，在where子句中使用子查询需要保证select语句与where子句中有相同数目的列（如此才能进行匹配）。事实上，子查询并不总是执行此类检索的最有效方法，在下一章节中我们会重现此例。 1.2 作为计算字段使用子查询 使用子查询的另一方法是创建计算字段。假如现在需要显示customers表中每个客户的订单总数。订单与相应的客户ID存储在orders表中。为了完成这个任务，首先需要从customers表中检索客户列表；然后对于每个检索出的客户，统计其在orders表中的订单数目。语句如下： 12345678910111213141516171819select cust_name, #输入 cust_state, (select count(*) from orders where orders.cust_id = customers.cust_id) as ordersfrom customersorder by cust_name;+----------------+------------+--------+ #输出| cust_name | cust_state | orders |+----------------+------------+--------+| Coyote Inc. | MI | 2 || E Fudd | IL | 1 || M. Martin | NY | 0 || Mouse House | OH | 0 || Pep E. LaPew | CA | 0 || Wascals | IN | 1 || Yosemite Place | AZ | 1 |+----------------+------------+--------+7 rows in set (0.85 sec) 此语句返回三个字段，其中orders为一个计算字段，它是由圆括号中的子查询建立的。该子查询对每个客户执行一次，此例中子查询执行了7次。此例中使用了完全限定表名（在前面的章节提到过），它告诉SQL比较orders表中的cust_id和当前正从customers表中检索的cust_id。这种类型的子查询称为相关子查询（涉及外部查询的子查询），在列名有多义性时需要这种语法，表名和列名间用一个句点分隔。 2. 组合查询 Mysql允许执行多个查询（多条select语句），并将结果作为单个查询结果返回，这些组合查询称为并（union）或符合查询（compound query）。在两种情况下需要使用组合查询： 在单个查询中从不同的表返回类似结构的数据； 对单个表执行多个查询，按单个查询返回数据。 2.1 创建组合查询 可以使用union操作符来组合多条SQL语句，将它们的结果组合成单个结果集。首先来看下面这个例子： 1234567891011121314151617181920select vend_id, prod_id, prod_price #输入from productswhere prod_price &lt;= 5unionselect vend_id, prod_id, prod_pricefrom productswhere vend_id in (1001,1002);+---------+---------+------------+ #输出| vend_id | prod_id | prod_price |+---------+---------+------------+| 1003 | FC | 2.50 || 1002 | FU1 | 3.42 || 1003 | SLING | 4.49 || 1003 | TNT1 | 2.50 || 1001 | ANV01 | 5.99 || 1001 | ANV02 | 9.99 || 1001 | ANV03 | 14.99 || 1002 | OL1 | 8.99 |+---------+---------+------------+8 rows in set (0.06 sec) union关键字的使用很加单，只需在各条select语句之间加上。该例检索了价格小于等于5的所有物品的一个列表，且包括供应商1001和1002生产的所有物品。显然，使用多个where子句也能完成该工作，且在本例中使用where子句和or操作符会更加简单。但是对于复杂的过滤条件（比如从多个表检索数据），使用union可能会使处理更简单。 注意，union关键字使用时，多个查询必须包含相同的列、表达式或聚集函数（但可以不以相同的次序给出）。其次，列数据类型必须兼容，即类型不必完全相同，但必须是DBMS可以隐含地转换类型。 2.2 包含或取消重复的行 在进行组合查询时，union关键字从查询结果集中自动去除了重复的行，与使用组合where子句的结果输出方式一致。这是UNION的默认行为，但在必要的情况下，可使用union all返回所有匹配行（这正好是使用组合where子句不能完成的工作）。 2.3 对组合查询结果排序 如果需要对组合查询的结果进行排序，只能使用一条order by子句，且它必须接在最后一条select语句之后（虽然只在最后一条语句中后接，但它实际上排序整个检索结果）。事实上，对结果集不存在用一种方式排序一部分，又用另一种方式排序另一部分，因此用多条order by子句是不合理的。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（六）——数据汇总与分组]]></title>
    <url>%2F2017%2F11%2F20%2Fmysql-6%2F</url>
    <content type="text"><![CDATA[本章节介绍利用Mysql对数据进行分类汇总，即对各个指定组别数据进行汇总（包括求和，均值，极值等）。实现分组的的SQL语句为select语句的group by子句和having子句，而数据汇总是利用SQL的聚集函数。 1. 汇总数据 通常，我们并不希望直接将实际数据检索出来而是查看数据的汇总信息，为此Mysql提供了专门的函数。这些函数使Mysql查询可用于检索数据，以便分析和生成数据报表。这类检索分为以下几种类型： 确定表中的行数（或者满足某个条件或包含某个特定值的函数）； 获得表中行组的和； 找出表列（或所有行或某些特定的行）的最大值、最小值和平均值等。 以上三种类型检索都需要对表中数据汇总而不是检索表数据本身，因此在此种情况下返回原始数据时对资源的浪费。Mysql提供了5个聚集函数（运行在行组上，计算和返回单个值的函数）方便完成数据汇总任务： 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 STD()/STDDEV_SAMP() 返回某列的标准差/样本标准差 VARIANCE()/VAR_SAMP() 返回某列的方差/样本方差 下面是几个使用聚集函数检索的例子： 123456789select avg(prod_price) as avg_price #输入from productswhere vend_id = 1003;+-----------+ #输出| avg_price |+-----------+| 13.212857 |+-----------+1 row in set (0.00 sec) 上述语句返回供应商ID为1003的产品价格均值。要注意，AVG()函数只能用来确定特定数值列的平均值，即括号内只能包含一个参数（对应列名，也可以是计算字段，即使用算数操作符连接的多个列），多个列求均值需要给出多个AVG()函数。聚合函数总是忽略值为NULL的行，但count()函数的第二种使用方式count(*)可以对表中各列非空值行进行计数。 如何只聚集不同的值？ 有的时候，或许我们只希望对列中不同的值进行进行汇总。其实，在数据检索那一章节中，我们已经使用distinct关键字实现对列中不同的值进行数据检索，而Mysql在聚集函数中也提供了完全类似的功能，该功能在Mysql 5.0.3版本之后可以正常运行。如下例： 123456789select avg(distinct prod_price) as avg_price #输入from productswhere vend_id = 1003;+-----------+ #输出| avg_price |+-----------+| 15.998000 |+-----------+1 row in set (0.00 sec) 注意，聚集函数中distinct关键字必须后接列名，不能用于计算或表达式。与之相对的是all关键字，它是默认情况下的参数，因此无需特别声明。 组合聚集函数 上述涉及的例子都只适用单个聚集函数，实际上select语句可以根据需要包含多个聚集函数。如下例： 1234567891011select count(*) as num_items, #输入 min(prod_price) as price_min, max(prod_price) as price_max, avg(prod_price) as price_avgfrom products;+-----------+-----------+-----------+-----------+ #输出| num_items | price_min | price_max | price_avg |+-----------+-----------+-----------+-----------+| 14 | 2.50 | 55.00 | 16.133571 |+-----------+-----------+-----------+-----------+1 row in set (0.00 sec) 2. 分组数据 目前为止，所有的计算都是在表的所有数据或匹配特定的where子句（数据过滤的方式）的数据上进行的。但如果现在我们需要返回每一个供应商的产品数目，那前述的方法就办不到了（当然可以遍历并分别检索，但供应商过多时工作量会非常大）。此时，分组的办法可以讲数据分为多个逻辑组，以便对每个组进行聚集计算。 2.1 创建分组 分组是在select语句中通过子句group by建立的。首先来看一个例子: 123456789101112select vend_id, count(*) as num_prods #输入from productsgroup by vend_id;+---------+-----------+ #输出| vend_id | num_prods |+---------+-----------+| 1001 | 3 || 1002 | 2 || 1003 | 7 || 1005 | 2 |+---------+-----------+4 rows in set (0.00 sec) 上面的例子指定了两个列，vend_id包含产品供应商的ID，num_prods为计算字段（count(*)）。group by子句指示Mysql按vend_id排序并分组数据，这使得对每个vend_id而不是整个表计算num_prods一次。因为使用了group by子句，就不用指定要计算和聚集的每个组了，系统会自动完成。 注意，group by子句可以包含任意数目的列，这使得能对分组进行嵌套，为数据分组提供更细致的控制。如果使用了嵌套分组，数据将在最后规定的分组上进行汇总。且group by子句中列出的各个列只能是检索列或者有效的表达式，如果在select语句中使用了表达式，则必须在group by子句中指定相同的表达式，不能使用别名。除聚集计算语句之外，select语句中的每个列都必须在group by中子句中给出。如果分组列中有NULL值，其将作为一个组返回（使用with rollup关键字可以显示NULL组）。在语句次序上，group by语句必须在where语句之后order by语句之前。 2.2 过滤分组 在分组数据时，Mysql还提供过滤分组功能（规定包括哪些分组，排除哪些分组）。实际上在前面数据过滤章节中，我们介绍通过where子句进行行过滤，但是其并不能实现分组过滤。Mysql为达成此任务提供了另外的子句——having子句。其实，之前使用的所有where子句都可以使用having子句来替代（将每行视为一个分组；where子句中的所有操作符同样可在having子句中使用）。下面举个例子： 123456789101112select vend_id, count(*) as num_prods #输入from productswhere prod_price &gt;= 10group by vend_idhaving count(*) &gt;= 2;+---------+-----------+ #输出| vend_id | num_prods |+---------+-----------+| 1003 | 4 || 1005 | 2 |+---------+-----------+2 rows in set (0.00 sec) 此条语句中，where子句过滤所有prod_price至少为10的行，然后按vend_id进行分组数据，而having子句过滤计数为2或2以上的分组。 分组和排序的区别 虽然order by和group by常常完成相同的工作，但实际上它们是非常不同的。首先order by可应用于非检索列，而group by不可以；且，group by子句实际只完成分组工作，并不会对分组结果进行排序。所以在有对输出结果顺序需求时，应该始终给出order by子句。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（五）——计算字段与函数]]></title>
    <url>%2F2017%2F11%2F17%2Fmysql-5%2F</url>
    <content type="text"><![CDATA[存储在数据库表中的数据往往都是原始数据，通常它们并非以我们需要的格式展现。比如，城市和邮政编码分别存储在同的列中，但邮件标签打印程序需要将它们作为一个字段（恰当格式）检索出来；物品订单表中分别存储了物品的价格和数量，但为了打印发票需要检索物品的总价格。为了实现上述目标，我们需要直接从数据库中检索出经过计算、转换或者格式化的数据（不能理解为检索出原始数据然后再利用相应软件完成此过程），这就是计算字段。计算字段并不实际存储在数据库表中，而是在运行时于select语句中创建的。 实际上，在SQL语句中完成的许多转换和格式化工作都可以在客户机上许多应用软件来完成，但是一般来说在数据库服务器上完成这些操作要比在客户机中更快（因为DBMS是设计来快速有效完成这种处理的）。 1. 创建计算字段1.1 拼接字段 拼接（concatenate）：将值连接到一起构成单个值。 首先举一个简单的例子，vendors表中包含供应商名和位置信息。假如现在需要生成一个供应商报表，需要在供应商的名字中按照name(location)这样的格式列出供应商的位置。此报表仅需要单个值，但数据库表中的相应数据存储在vend_name和vend_country中，此外还需要将vend_country用括号括起来。上述要求可以在Mysql的select语句中使用concat()函数来实现拼接这两个列。如下： 1234567891011121314select concat(vend_name,'(',vend_country,')') #输入from vendorsorder by vend_name;+----------------------------------------+ #输出| concat(vend_name,'(',vend_country,')') |+----------------------------------------+| ACME(USA) || Anvils R Us(USA) || Furball Inc.(USA) || Jet Set(England) || Jouets Et Ours(France) || LT Supplies(USA) |+----------------------------------------+6 rows in set (0.02 sec) 可见，concat()函数将其括号内的参数进行拼接，各个参数之间由逗号分隔。注意，在数据类型为字符串时容易疏忽掉空格，Mysql提供rtrim()函数和ltrim()函数来分别实现去掉字符串右边和左边的空格。如下： 123select concat(rtrim(vend_name),'(',rtrim(vend_country),')') #输入from vendorsorder by vend_name; 1.2 使用别名 从上例可以看出，输出的拼接字段结果实际上是没有名字的，它只是一个值。要在客户机应用中应用该拼接字段或许会出现困难，SQL为了解决这个问题而支持列别名。别名是一个字段或值的替换名，使用as关键字赋予。如下例： 1234567891011121314select concat(vend_name,'(',vend_country,')') as vend_title #输入from vendorsorder by vend_name;+------------------------+ #输出| vend_title |+------------------------+| ACME(USA) || Anvils R Us(USA) || Furball Inc.(USA) || Jet Set(England) || Jouets Et Ours(France) || LT Supplies(USA) |+------------------------+6 rows in set (0.00 sec) 上述语句本身作用与上一个例子相同，但本语句在计算字段之后跟了as vend_title。它指示SQL创建一个包含指定计算的名为vend_title的计算字段。任何客户机应用都可以按名引用这个列。 1.3 执行算数计算 除了拼接字段，计算字段的第二种常见用途是对检索的数据进行算数运算。首先来看下面这个例子： 123456789101112select prod_id, quantity, item_price, quantity*item_price as expanded_price #输入from orderitemswhere order_num = 20005;+---------+----------+------------+----------------+ #输出| prod_id | quantity | item_price | expanded_price |+---------+----------+------------+----------------+| ANV01 | 10 | 5.99 | 59.90 || ANV02 | 3 | 9.99 | 29.97 || TNT2 | 5 | 10.00 | 50.00 || FB | 1 | 10.00 | 10.00 |+---------+----------+------------+----------------+4 rows in set (0.15 sec) 上述语句检索出了订单号为20005的所有物品，并检索出它们的产品ID，产品数量，产品单价和总价。其中产品总价expanded_price为一个计算字段，此计算为quantity*item_price,列别名为expanded_price。如下给出Mysql支持的基本算数操作符，此外圆括号可以用来区分优先顺序： 操作符 说明 + 加 - 减 * 乘 / 除 可以使用select语句测试计算，比如select 2*5;将返回10。 2. 使用数据处理函数 同其他计算语言一样，SQL支持利用函数来处理数据，如前面已经用过的concat()函数。函数一般是在数据上执行的，它给数据的转换和处理提供了方便。注意，相比SQL语句函数的可移植性并不强，几乎每种DBMS都支持只适用于本身的函数。因此，在使用函数时最好进行代码注释。大多数SQL实现支持以下类型的函数： 用于处理文本串的文本函数（如删除、填充或转换值）。 用于在数值数据上进行算数操作的数值函数（如返回绝对值，进行代数运算）。 用于处理日期和时间的函数（如返回两个日期差等等）。 返回DBMS特殊信息的函数（如用户登录信息，版本信息）。 2.1 文本处理函数 函数 说明 left() 返回串左边的字符 length() 返回串的长度 locate() 找出串的一个子串 lower() 将串转换为小写 ltrim() 去掉串左边的空格 right() 返回串右边的字符 rtrim() 去掉串右边的空格 soundex() 返回串的soundex值 substring() 返回子串的字符 upper() 将串转换为大写 注意，SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。如下例： 123456789select cust_name, cust_contact #输入from customerswhere soundex(cust_contact) = soundex('Y. Lie');+-------------+--------------+ #输出| cust_name | cust_contact |+-------------+--------------+| Coyote Inc. | Y Lee |+-------------+--------------+1 row in set (0.09 sec) 2.2 日期和时间处理函数 日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。一般，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。如下是常用的日期和时间处理函数： 函数 说明 adddate() 增加一个日期（天、周等） addtime() 增加一个时间（时、分等） curdate() 返回当前日期 curtime() 返回当前时间 date() 返回日期时间的日期部分 datediff() 计算两个日期之差 date_add() 高度灵活的日期计算函数 date_format() 返回一个格式化日期或时间串 day() 返回一个日期的天数部分 day0fweek() 对于一个日期，返回对应的星期几 hour() 返回一个时间的小时部分 minute() 返回一个时间的分钟部分 month() 返回一个时间的月份部分 now() 返回当前日期和时间 second() 返回一个时间的秒部分 time() 返回一个日期时间的时间部分 year() 返回一个日期的年份部分 注意，在Mysql中使用的日期格式为yyyy-mm-dd，虽然一些其他格式也可行，但这是首选的日期格式（它排除了多义性）。如下例： 123456789select cust_id, order_num #输入from orderswhere date(order_date) = '2005-09-01';+---------+-----------+ #输出| cust_id | order_num |+---------+-----------+| 10001 | 20005 |+---------+-----------+1 row in set (0.09 sec) 2.3 数值处理函数 此类函数仅处理数值函数，一般主要用于代数、三角或几何运算，因此没有串或日期-时间处理函数的使用那么频繁。如下表： 函数 说明 abs() 返回一个数的绝对值 cos() 返回一个角度的余弦 exp() 返回一个数的指数值 mod() 返回除法操作的余数 pi() 返回圆周率 rand() 返回一个随机数 sin() 返回一个角度的正弦 sqrt() 返回一个数的平方根 tan() 返回一个角度的正切]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（四）——数据过滤]]></title>
    <url>%2F2017%2F11%2F16%2Fmysql-4%2F</url>
    <content type="text"><![CDATA[数据库表包含了大量的数据，通常我们并不期望检索表中的所有行。正如在上一章节中采用limit子句实现结果限定一样，更一般地，我们希望准确检索到表中的特定数据（即表中数据的子集）。这需要在select语句检索中指定搜索条件来完成，搜索条件也称为过滤条件。本章节通过介绍select语句中的where子句，通配符以及正则表达式来实现数据过滤。 1. 使用WHERE子句过滤数据 在select语句中，数据根据where子句中指定的搜索条件进行过滤。注意使用多个子句时的次序，如果出现order by子句，那么where子句需要使用在前者之前，否则将会报错。 1.1 WHERE子句条件操作符 首先来看一个例子： 12345678910select prod_name, prod_price #输入from productswhere prod_price = 2.5;+---------------+------------+ #输出| prod_name | prod_price |+---------------+------------+| Carrots | 2.50 || TNT (1 stick) | 2.50 |+---------------+------------+2 rows in set (0.01 sec) 上述语句表示从products表中检索两个列，但不返回其所有行而是返回prod_price等于2.5的行。这个例子采用简单的相等搜索条件，它检查一个列是否具有指定的值，并据此进行过滤，但是SQL能够实现不只如此。下面列出了更多WHERE子句操作符： 操作符 说明 操作符 说明 = 等于 &lt;&gt; 不等于 &lt; 小于 != 不等于 &gt; 大于 &lt;= 小于等于 &gt;= 大于等于 between 在指定两个值之间 注意，需要使用单引号来限定字符串，如果将值与串类型的列进行比较则需要限定引号，而与数值比较时不需要。下例使用了BETWEEN操作符，其语法与其他WHERE子句操作符略有不同，它需要提供两个值（即范围的起始值和结束值）并使用and关键连接，BETWEEN则匹配该范围中的所有值包括端点值。 12345678910111213select prod_name, prod_price #输入from productswhere prod_price between 5 and 10;+----------------+------------+ #输出| prod_name | prod_price |+----------------+------------+| .5 ton anvil | 5.99 || 1 ton anvil | 9.99 || Bird seed | 10.00 || Oil can | 8.99 || TNT (5 sticks) | 10.00 |+----------------+------------+5 rows in set (0.01 sec) 如何进行空值检查？ 在创建表时，设计人员可以指定其中的列是否可以不包含值。一个列不包含值时，称其为包含空值NULL。要注意，空值与字段包含0、空字符串、空格不同。select语句中有一条特殊的where子句，可以实现检索具有空值的列，如下例： 1234select prod_name #输入from productswhere prod_price is null;Empty set (0.00 sec) #输出 这条语句返回没有价格（空prod_price字段，非价格为0）的所有产品，由于表中没有这样的行，所以没有返回数据。注意，在通过筛选不具有特定值（&lt;&gt;条件操作符）的行时，可能希望返回具有NULL值的行，但是实际上未知是有特定含义的，数据库不知道它们是否匹配所以不会返回NULL值，需要进行进一步验证。 组合WHERE子句 上述介绍的所有where子句在过滤数据时使用的都是单一的条件，实际中往往需要通过多个where子句建立更强更高级的搜索条件。Mysql可以通过and和or操作符连接多条where子句。如下例： 12345678910111213select prod_id, prod_price, prod_name #输入from productswhere vend_id = 1003 and prod_price &lt;= 10;+---------+------------+----------------+ #输出| prod_id | prod_price | prod_name |+---------+------------+----------------+| FB | 10.00 | Bird seed || FC | 2.50 | Carrots || SLING | 4.49 | Sling || TNT1 | 2.50 | TNT (1 stick) || TNT2 | 10.00 | TNT (5 sticks) |+---------+------------+----------------+5 rows in set (0.00 sec) 上述语句检索供应商ID为1003且价格小于等于10美元的所有产品，and关键字用在where子句中可检索同时满足给定条件的行。当然，可以将更多过滤条件组合在一起，但每添加一条就需要再加一个关键字。 类似地，or操作符用在where子句中可检索满足任一给定条件的行。需要特别注意的是，where子句可包含任意数目的and和or操作符，两者结合可以实现更复杂的检索。但组合and和or会面临一个问题——处理次序。SQL在处理or操作符前会优先处理and操作符，即and的优先级更高。为了避免出现歧义和错误，可以使用圆括号对操作符进行明确的分组，而不应该过分依赖默认次序。 WHERE子句中的IN操作符和NOT操作符 in：in操作符用来指定条件范围，范围中的每个条件都可以进行匹配。 not：not操作符是用来否定后跟条件的关键字。 1234567891011121314select prod_name, prod_price #输入from productswhere vend_id not in (1002,1003)order by prod_name;+--------------+------------+ #输出| prod_name | prod_price |+--------------+------------+| .5 ton anvil | 5.99 || 1 ton anvil | 9.99 || 2 ton anvil | 14.99 || JetPack 1000 | 35.00 || JetPack 2000 | 55.00 |+--------------+------------+5 rows in set (0.00 sec) 要注意，此处的(1002,1003)并非代表一个区间，而是包含1002及1003这两个元素的集合。区间的表示是使用between操作符。 上例语句检索了非1002及1003供应商的所有产品及其价格，并按照产品名进行排序。可以看出，in操作符的功能与or功能非常相似，实际上，在使用多个过滤条件时in操作符更加清楚直观执行更快（因为它使用的操作符更少）。in操作符的最大优点在于它可以包含其他select语句（子查询），在后续的章节中会对它进行介绍。同样地，not关键字可以简化更加复杂的多个过滤条件，提高效率。 2. 使用通配符进行过滤 前文介绍的所有操作符都是针对已知值进行过滤的，但有的时候我们对自己要检索的数据了解得并不是那么全面或者说清楚。比如，如何检索在产品名中包含文本“jet”的所有产品？显然，前文提供的方法都行不通，因为我们不清楚自己要检索的产品名称具体是什么，这时，我们需要使用通配符创建特定的搜索模式。 在搜索子句中要使用通配符，必须使用like操作符。like指示Mysql后跟的搜索模式利用通配符匹配，而不是直接相等匹配进行比较。 通配符（wildcard）：用来匹配值的一部分的特殊字符。 搜索模式（search pattern）：由字面值、通配符或两者组合构成的搜索条件。 谓词（predicate）：操作符何时不是操作符？答案是在它作为谓词时。（从技术上说，like是谓词而不是操作符，虽然最终的结果是相同的，但需要对此术语进行了解，以免在SQL文档中遇到此术语时不知道）。 2.1 百分号（%）通配符 最常使用的通配符是百分号（%）。在搜索中，%表示任何字符出现任意次数。例如，为了找出所有产品名以“jet”起始的产品，可以使用如下select语句： 12345678910select prod_id, prod_name #输入from productswhere prod_name like 'jet%';+---------+--------------+ #输出| prod_id | prod_name |+---------+--------------+| JP1000 | JetPack 1000 || JP2000 | JetPack 2000 |+---------+--------------+2 rows in set (0.00 sec) 此例使用的搜索模式为’jet%’，在执行这条子句时将检索任意以“jet”起头的词。%告诉Mysql接受“jet”之后的任意字符。注意，通配符可以在搜索模式中任意位置中使用，并且可以使用多个通配符。如下例： 123select prod_id, prod_name #输入from productswhere prod_name like '%anvil%' #表示匹配任何位置包含文本anvil的值 注意，%代表搜索模式中给定位置的0个，1个或多个字符（NULL除外，即like &#39;%&#39;也不能匹配NULL值，而空格不是空值是字符不要疏忽）。 2.2 下划线（_）通配符 下划线通配符与百分号通配符用途基本一致，但是下划线只匹配单个字符而不是多个。如下例： 12345678910select prod_id, prod_name #输入from productswhere prod_name like '_ ton anvil';+---------+-------------+ #输出| prod_id | prod_name |+---------+-------------+| ANV02 | 1 ton anvil || ANV03 | 2 ton anvil |+---------+-------------+2 rows in set (0.00 sec) 正如上述，Mysql通配符功能强大，但是这种共也是有代价的，使用通配符的检索处理往往比其他检索花的时间更长。因此，不要过度使用通配符（如果其他操作符能达到相同目的尽量使用其他操作符）。除非绝对必要，尽量不要讲通配符置于开始处，这样检索起来是最慢的。其次，要特别注意通配符的位置，如果位置错误可能不会返回你想要的数据。 3. 使用正则表达式进行检索 对于基本的检索和过滤，前文使用的匹配、比较和通配符基本可以实现。但如果过滤条件更加复杂，比如从文本块中提取电话号码，找到重复单词等等目标，仅仅采用前文方法就不足以实现。正则表达式是通过正则表达式语言来建立，可以完成上述及更广泛目标（匹配文本）的特殊语言。Mysql用where子句对正则表达式提供了初步支持（Mysql仅支持多数正则表达式实现的一个很小的子集），允许指定正则表达式来过滤select语句检索出的数据。 3.1 基本字符匹配 首先来看下面这个例子： 1234567891011select prod_name #输入from productswhere prod_name regexp '.000'order by prod_name;+--------------+ #输出| prod_name |+--------------+| JetPack 1000 || JetPack 2000 |+--------------+2 rows in set (0.00 sec) 这里使用了正则表达式&#39;.000&#39;。其中.是正则表达式语言中的一个特殊字符，它表示匹配任意一个字符。regexp关键字告诉Mysql后跟的东西作为正则表达式处理。当然，这个特殊的例子也可以通过like关键字和通配符来完成。注意，like和regexp的区别，like匹配整个列（如果不使用通配符来帮助的话），而regexp在列值内进行匹配。Mysql中的正则表达式不区分大小写，若要区分可使用binary关键字，如where prod_name regexp binary &#39;JetPack .000&#39;。 3.2 进行OR匹配 见下面这个例子： 1234567891011select prod_name #输入from productswhere prod_name regexp '1000|2000|3000'order by prod_name;+--------------+ #输出| prod_name |+--------------+| JetPack 1000 || JetPack 2000 |+--------------+2 rows in set (0.00 sec) |是正则表达式中的OR操作符，它表示匹配其中之一。 3.3 匹配几个字符之一 要匹配特定的字符，可以使用一组被[和]括起来 字符来完成。如下例： 1234567891011select prod_name #输入from productswhere prod_name regexp '[123] ton'order by prod_name;+-------------+ #输出| prod_name |+-------------+| 1 ton anvil || 2 ton anvil |+-------------+2 rows in set (0.00 sec) 这里，[123]定义一组字符，它的意思是匹配1或2或3。正如所见，[]是另一种形式的OR语句，它是[1|2|3] ton的缩写，也可以使用后者。至于为和需要用[]来定义OR语句要查找什么，各位可以自己试一试去掉[]会发生什么。注意，字符集合也可以被否定（即，它们将匹配除指定字符外的任何东西，这一目的通过在[]内开始处放置一个^来完成，如[^123]）。 3.4 匹配范围 集合可以用来定义要匹配的一个或多个字符，比如[123456789]。但显然，当字符元素过多时，使用这种表达将会变得麻烦而且容易出错。可以使用-来定义一个范围，达到简化集合的作用，如下例： 1234567891011select prod_name #输入from productswhere prod_name regexp '[1-3] ton'order by prod_name;+-------------+ #输出| prod_name |+-------------+| 1 ton anvil || 2 ton anvil |+-------------+2 rows in set (0.00 sec) 注意，范围不一定只可以是数值的，比如[a-z]匹配任意字母字符。 3.5 匹配特殊字符 此处所说的特殊字符是正则表示语言中使用过的字符，比如要匹配文本中的“.”，而.在正则表达式中有特殊含义，因此此处需要使用转义（由\\来引导），如下例： 12345678910select vend_name #输入from vendorswhere vend_name regexp '\\.'order by vend_name;+--------------+ #输出| vend_name |+--------------+| Furball Inc. |+--------------+1 row in set (0.01 sec) 3.6 匹配字符类 实际中会遇到检索自己常使用的数字、所有字母字符或所有数字字母字符等的匹配。为了方便起见，可以使用预定的字符集，称为字符类（character class）。见下表： 类 说明 [:alnum:] 任意数字和字母（同[a-zA-Z0-9]） [:alpha:] 任意字符（同[a-zA-Z]） [:blank:] 空格和制表（同[\\t]） [:cntrl:] ASCII控制字符（ASCII0到31和127） [:digit:] 任意数字（同[0-9]） [:graph:] 与[:print:]相同但不包括空格 [:lower:] 任意小写字母（同[a-z]） [:print:] 任意可打印字符 [:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符 [:space:] 包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]） [:upper:] 任意大写字母（同[A-Z]） [:xdigit:] 任意十六进制数字（同[a-fA-F0-9]） 3.7 匹配多个实例 目前使用的所用正则表达式都试图匹配单词出现，有时候，需要的检索对匹配的数目控制更强。例如，想要搜寻所有的数，不管包含都少个数字，或者寻找一个单词且还能够适应一个尾随的s（如果存在）等等。这可以通过正则表达式的重复元字符来完成。下面是正则表达式重复元字符表: 元字符 说明 * 0个或多个匹配 + 1个或多个匹配 ? 0个或1个匹配 {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 {n,m} 匹配数目的范围（m不超过225） 下面是一个使用重复元字符的例子： 1234567891011select prod_name #输入from productswhere prod_name regexp '\\([0-9] sticks?\\)' #？使其前一个字母s可选order by prod_name;+----------------+ #输出| prod_name |+----------------+| TNT (1 stick) || TNT (5 sticks) |+----------------+2 rows in set (0.00 sec) 3.8 定位符 前述所有例子都是匹配一个串中任意位置的文本，想要匹配特定位置的文本需要使用下表列出的定位符： 定位元字符 说明 ^ 文本的开始 $ 文本的结尾 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结尾 例如，若想找出一个数（包括以一个小数点开始的数）开头的所有产品名： 123456789101112select prod_name #输入from productswhere prod_name regexp '^[0-9\\.]'order by prod_name;+--------------+ #输出| prod_name |+--------------+| .5 ton anvil || 1 ton anvil || 2 ton anvil |+--------------+3 rows in set (0.00 sec) 注意，^有双重用途，在集合中（由[和]定义）它用于否定该集合；否则，它用来指串的开始处。 如何测试正则表达式？ 实际中可以在不使用数据库表的情况下用select来测试正则表达式，此时，regexp总是返回0（没有匹配）或1（匹配）。例如select &#39;hello&#39; regexp &#39;[0-9]&#39;;，这个例子返回的结果是0。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>通配符</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（三）——数据检索与排序]]></title>
    <url>%2F2017%2F11%2F15%2Fmysql-3%2F</url>
    <content type="text"><![CDATA[本节介绍数据的检索与排序，此操作将由select语句及其子句order by分别实现。要知道，SQL语句是由简单的英语单词构成，如select，create这些单词在SQL语言中被称为关键字。接触过SQL语言的小伙伴应该知道select基本算是最常使用的SQL关键字了，它几乎就是SQL的象征，下面是select的表演时间。 1. 检索数据 首先，select语句的用途是从一个或多个表中检索信息，而要使用其来检索表数据至少需要给出两条信息：一是想检索的是什么，二是从什么地方进行检索（比如你要检索的信息来自哪张表）。 1.1 检索单个列 比如，想从产品表（products）中检索产品名对应的列（prod_name）,需要select语句后接列名，并使用from关键字指出存放该数据的表。 123456789101112131415161718192021select prod_name #输入from products; +----------------+ #输出| prod_name |+----------------+| .5 ton anvil || 1 ton anvil || 2 ton anvil || Detonator || Bird seed || Carrots || Fuses || JetPack 1000 || JetPack 2000 || Oil can || Safe || Sling || TNT (1 stick) || TNT (5 sticks) |+----------------+14 rows in set (0.05 sec) 上述select语句返回products表中prod_name这一列的所有行，且没有经过排序（也就是说重复上述语句输出的结果顺序可能不一致，要知道没有经过排序而考察顺序是毫无意义的，只要行数一致就是正常的）。 注意，SQL关键字不区分大小写。在处理SQL语句时其中的空格都将被忽略，即SQL语句可以在一行给出也可以进行分行（分行会使语句更容易阅读和调试）。多条语句间必须使用;加以分割，在多数的DBMS中，单条语句后;可加可不加，但是如果使用的是mysql命令行实用程序，必须加上;来结束SQL语句。 1.2 检索多个列 如果想要从一张表上检索多个列，也采用与上述相同的select语句，但select关键字后需要给出多个列名且列名之间用逗号分隔。比如，想要从产品表（products）中检索产品号（prod_id），产品名（prod_name），产品价格（prod_price）信息。 123456789101112131415161718192021select prod_id, prod_name, prod_price #输入from products;+---------+----------------+------------+ #输出| prod_id | prod_name | prod_price |+---------+----------------+------------+| ANV01 | .5 ton anvil | 5.99 || ANV02 | 1 ton anvil | 9.99 || ANV03 | 2 ton anvil | 14.99 || DTNTR | Detonator | 13.00 || FB | Bird seed | 10.00 || FC | Carrots | 2.50 || FU1 | Fuses | 3.42 || JP1000 | JetPack 1000 | 35.00 || JP2000 | JetPack 2000 | 55.00 || OL1 | Oil can | 8.99 || SAFE | Safe | 50.00 || SLING | Sling | 4.49 || TNT1 | TNT (1 stick) | 2.50 || TNT2 | TNT (5 sticks) | 10.00 |+---------+----------------+------------+14 rows in set (0.00 sec) 注意，SQL语句一般返回原始、无格式的数据。数据展现的格式是一个表示问题，而不应包括在数据的检索中。 1.3 检索所有列 要检索出一张表的所有列，同样使用上述相同的select语句，但不需要逐个列出表中的所有列。这可以采用*通配符来实现，事实上*通配符的好处在于你或许不知道所有列的列名，而通过它能检索出未知列。其语句如下： 1select * from products; #输入 如何实现检索不同的行？ 如上述，select语句的结果返回被检索列的所有行，比如检索产品表（products）中供应商ID（vend_id）这一列，返回结果： 1234567891011121314151617181920select vend_id from products; #输入+---------+ #输出 | vend_id |+---------+| 1001 || 1001 || 1001 || 1002 || 1002 || 1003 || 1003 || 1003 || 1003 || 1003 || 1003 || 1003 || 1005 || 1005 |+---------+14 rows in set (0.02 sec) 虽然结果显示返回14行（因为products表中列出了14个产品），但是容易看到实际表中只有4个供应商，想要只返回列中的不同值需要用到distinct关键字，它指示Mysql只返回不同值。 1234567891011select distinct vend_id #输入from products;+---------+ #输出 | vend_id |+---------+| 1001 || 1002 || 1003 || 1005 |+---------+4 rows in set (0.05 sec) 注意，distinct关键字应用于给出的所有列儿不仅仅只是前置它的列。 如何限制输出？ 或许在有些情况下，你只希望查看某一列的前几行，在select语句中家加入limit子句可以实现这一任务。下面给出两个例子： 123456789101112select prod_name from products #输入limit 5;+--------------+ #输出 | prod_name |+--------------+| .5 ton anvil || 1 ton anvil || 2 ton anvil || Detonator || Bird seed |+--------------+5 rows in set (0.00 sec) 上述语句中，limit 5指示Mysql返回前5行。 123456789101112select prod_name from products #输入limit 5, 5;+--------------+ #输出| prod_name |+--------------+| Carrots || Fuses || JetPack 1000 || JetPack 2000 || Oil can |+--------------+5 rows in set (0.00 sec) 上述语句可以得到下一个5行，limit 5, 5指示Mysql返回从行5开始的5行，其中第一个数表示开始位置，第二个数表示要检索的行数。注意此处的第一个参数为行的索引号而不是真实的行序号，实际上行的索引号比行序号要小1，即第1行为行0而不是行1。且要注意带一个值的limit总是从第一行开始，给出的数为返回的行数；而带两个值的limit是从第一个值的位置开始返回行，返回行数为第二个值。limit语句还有一种替代语法，例如limit 5 offset 2，它等同于limit 2, 5。 2. 排序检索数据 在前一部分的数据检索中使用的select语句输出中可以看到，返回结果是没有特定顺序的。实际上，以此方式检索出的数据并非以纯粹的随机顺序显示。如果不进行排序，数据一般讲以它在底层表中出现的顺序显示，这可能是数据最开始添加到表中的顺序。但是，如果数据后来进行过更新或者删除，则此顺序会受到Mysql重用回收存储空间的影响，也就是说在没有明确控制顺序的情况下此输出结果的顺序是没有参考价值的。 子句（clause）： 一个子句通常由一个关键字和所提供的数据组成。一条完整的SQL语句可包含子句，有些子句是必须的（比如select语句中的from子句，通过它确定需要提取列所在的表），而有些子句是可选的。 2.1 排序数据 为了对select语句检索出的数据进行排序，可以使用order by子句确定一个或多个列名，并据此对输出进行排序。注意，通常order by子句中所使用的列是select语句中选择的列，但也可以不是（即使用其他列对select语句中的列进行排序也是可以的）。下面是数据排序的一个例子： 12345678910111213141516171819202122select prod_id, prod_price, prod_name #输入from productsorder by prod_price, prod_name+---------+------------+----------------+ #输出| prod_id | prod_price | prod_name |+---------+------------+----------------+| FC | 2.50 | Carrots || TNT1 | 2.50 | TNT (1 stick) || FU1 | 3.42 | Fuses || SLING | 4.49 | Sling || ANV01 | 5.99 | .5 ton anvil || OL1 | 8.99 | Oil can || ANV02 | 9.99 | 1 ton anvil || FB | 10.00 | Bird seed || TNT2 | 10.00 | TNT (5 sticks) || DTNTR | 13.00 | Detonator || ANV03 | 14.99 | 2 ton anvil || JP1000 | 35.00 | JetPack 1000 || SAFE | 50.00 | Safe || JP2000 | 55.00 | JetPack 2000 |+---------+------------+----------------+14 rows in set (0.00 sec) 此例是检索产品表中的产品ID，产品价格和产品名，并对输出结果按照产品价格和产品名进行排序（先按价格排序，再按名称排序）。注意，在按照多个列进行排序时，排序完全按照所规定的顺序进行（在本例中如果多个行具有相同的价格则咱其名称进行再排序）。 2.2 指定排序的方向 数据排序不限于升序排序（这是默认的排序顺序），还可以通过在order by子句中指定desc关键字对输出结果进行降序排序。如下例： 12345678910111213141516171819202122select prod_id, prod_price, prod_name #输入from productsorder by prod_price desc;+---------+------------+----------------+ #输出| prod_id | prod_price | prod_name |+---------+------------+----------------+| JP2000 | 55.00 | JetPack 2000 || SAFE | 50.00 | Safe || JP1000 | 35.00 | JetPack 1000 || ANV03 | 14.99 | 2 ton anvil || DTNTR | 13.00 | Detonator || FB | 10.00 | Bird seed || TNT2 | 10.00 | TNT (5 sticks) || ANV02 | 9.99 | 1 ton anvil || OL1 | 8.99 | Oil can || ANV01 | 5.99 | .5 ton anvil || SLING | 4.49 | Sling || FU1 | 3.42 | Fuses || FC | 2.50 | Carrots || TNT1 | 2.50 | TNT (1 stick) |+---------+------------+----------------+14 rows in set (0.00 sec) 注意，desc关键字只应用到直接位于其前面的列名，位于其后的列名仍然按默认的升序。如果想在多个列上进行降序排序，需要对order by后的每个列名指定desc关键字。与desc关键字相反的是asc关键字，但升序是默认的排序方式，所以无需特别指定。 其次，要特别注意各个子句出现的次序（比如order by子句出现在from子句之后，而limit子句出现在order by子句之后），子句次序混乱将会报错。 如何检索一列中最高或者最底的值？ 到目前为止order by以及limit子句可以帮助实现这一检索，have a try!]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（二）——连接服务器]]></title>
    <url>%2F2017%2F11%2F14%2Fmysql-2%2F</url>
    <content type="text"><![CDATA[前一章节介绍了数据库基本概念，在有可使用的服务器和客户机软件之后，连接到数据库是执行后续操作的首要步骤。所有的图形化客户机软件都提供服务器连接窗口，本小白使用的是最原始的Mysql命令行实用程序，后续展现的代码也是基于该客户机工具。 服务器连接要连接到服务器需要知道其四个基本信息：主机名，端口，用户名以及口令。 主机名：也是计算机名，如果连接的是本地Mysql服务器则为localhost。 端口：如果使用默认端口3306之外的端口需要提供其端口号。（在网络上，各主机通过TCP/IP协议进行数据交互，而主机上有多程序同时运行，要将数据准确传输到某个特定的程序就需要引入端口机制将各个程序与特定端口号对应，进而实现针对到程序间的数据交互。） 用户名 用户名口令：就是对应的密码。 在命令提示符下输入: 1mysql -h localhost -u root -p *** -P 3306 #-h后跟主机名 -u后跟用户名 -p后跟口令 -P后跟端口号 输入完成后会出现如下一个简单提示： 12345678910111213Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.7.19-log MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 注意，如果连接本地服务器出现错误，请检查本地Mysql服务是否开启，或许需要手动开启服务。后续命令输入在mysql&gt;之后，命令用；结束，输入quit或exit退出Mysql命令行实用程序。 选择数据库 要知道，在最初连接到Mysql时，没有任何数据库打开供你使用，你需要选择一个数据库进而执行其他数据库操作。如果你不知道可以使用的数据库名，可以使用show关键字来显示数据库信息。下面是一个简单的例子： 123456789101112show databases; #输入+--------------------+ #输出| Database |+--------------------+| information_schema || cda1 || crashcourse || mysql || performance_schema || sys |+--------------------+6 rows in set (0.04 sec) 此处返回一个数据库列表，列表中是Mysql内部可能使用的数据库。下一步选择你想进入的数据库，如下： 12use crashcourse; #输入Database changed #输出 注意，use语句不返回任何结果，依赖于使用的客户机软件，显示某种形式的通知。必须先使用use语句打开数据库才能读取其中的数据。 关于show语句 更多的show语句可以在Mysql命令行实用程序中，执行help show;进行查看，此处列出两个常用show语句： 123456789101112show tables; #输入+-----------------------+ #输出| Tables_in_crashcourse |+-----------------------+| customers || orderitems || orders || productnotes || products || vendors |+-----------------------+6 rows in set (0.00 sec) 注意，show tables;返回正在使用的数据库内的表的列表。 1234567891011show columns from products; #输入+------------+--------------+------+-----+---------+-------+ #输出| Field | Type | Null | Key | Default | Extra |+------------+--------------+------+-----+---------+-------+| prod_id | char(10) | NO | PRI | NULL | || vend_id | int(11) | NO | MUL | NULL | || prod_name | char(255) | NO | | NULL | || prod_price | decimal(8,2) | NO | | NULL | || prod_desc | text | YES | | NULL | |+------------+--------------+------+-----+---------+-------+5 rows in set (0.12 sec) 注意，show columns语句要求指定一个数据库内的表名，此例中使用的是products表，它对每个表中的每个字段返回一行（包含了各行数据类型，允许空值与否，主外键，默认值及额外信息）。show columns还有一种快捷方式，使用describe products会返回如上相同的结果。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（一）——数据库基础概念]]></title>
    <url>%2F2017%2F11%2F13%2Fmysql-1%2F</url>
    <content type="text"><![CDATA[在写这篇文章之前，我只花了一小段时间大致对《Mysql必知必会》这本小册子翻看了一遍。作为新入坑小白的我知道使用数据库是每位数据科学相关工作者的必备技能，在深入学习之前，理解关于它的基本概念及术语对后续的学习会有很大的帮助。 那么，初步接触数据库的第一个问题，十有八九，为什么要学习数据库或者数据有什么用？像这样的问题，作为数学和统计专业出身的我只会微微一笑，当然，数据库毕竟不是单纯的理论。给大家举个例子，假设各位看官开了一家书店，那么如何摆放书籍便于你自己还有前来买书的人搜寻就是一个需要解决的难题。如果说你的书店只卖两本书，那或许考虑怎么摆书是徒劳无功的，但如果你的书店有两万本各不相同书呢？现实情况往往更类似于后者。这样，你就需要将书进行分类以及整理，不同的店家有不同的方法，但需要告诉别人整理摆放的规则使所有的人都能按需检索。现今，有许多企业都拥有非常大规模的数据，虽然它们分别属于不同的行业，但都同样面临管理数据的问题，而数据库技术就能帮助解决这一难题。 要知道其实生活中，我们一直都在使用数据库，比如利用搜索引擎检索、查询自己的银行账户余额等等。数据库技术针对于数据管理，是计算机科学的重要分支。但由于一些原因，不同的人会使用相同的数据库术语表示不同的事物，所以对于本对其就不清楚的小白来说更加混乱。下面，我将列出一些数据库术语并加以说明。 基本术语： 数据库（Database, DB）：数据库是指一种可共享的，以某种有组织的方式存储在计算机内的数据集合。（简单理解，可以将其想象为是保存有组织数据的容器，比如一个文件夹，是存放数据的物理位置。） 数据库管理系统（Database Management System, DBMS）:数据库软件也称为DBMS，通过它我们可以创建和操纵数据库。（通常会看到一些人使用数据库这个术语来代表他们使用的数据库软件，但这是不正确的而且容易引起混淆，因为一般来说我们并不直接访问数据库而是通过DBMS。） SQL（Structrued Query Language）:结构化查询语言，是一种专门用来与数据库通信的语言。（几乎所有DBMS都支持SQL，它不是由某个特定数据库供应商专有的，但也并非所有语句都是可移植于不同DBMS。） 表（table）:某种特定类型数据的结构化清单。（比如，想要将数据放进文件夹，首先需要在其中创建文件，然后将相关的数据放入特定的文件中。可以将数据库中的表想象成这里的文件，表是一种结构化的文件，用来存储某种特定类型的数据，每个表都有一个自己的名字。） 模式（schema）:是关于表和数据库信息的特性和结构的信息。（每个表都有一定的特性，这些特性决定了数据在各个表中如何存储，用于描述表的这组信息以及数据库中各个表之间的关系即为模式。） 列（column）:表中的一个字段。（表由列组成，每一列都存储着一条特定的信息。比如客户信息表中，客户编号、姓名、住址分别记录于各个列中。将数据有效的分解为多个列是有非常必要的，否则在排序和过滤时会非常困难。） 行（row）:表中的一个记录。（例如，客户信息表中每行存储着一个客户。行和记录这两个术语可以互相替代，但从技术层面讲，行才是正确的术语。） 主键（primary key）:一列或一组列，其值可以唯一区分表中的每个行。（例如客户信息表中，可用客户编号列作为主键。若没有主键，更新或删除表中特定行将变得困难，因为没有安全的方法保证只涉及相关的行。） 关于Mysql 前文说到了数据库管理系统，数据的管理、处理实际都是由数据库软件，即DBMS完成的。而Mysql就是DBMS的一种，知名的DBMS还有Oracle,SQL Server,DB2等等。至于为什么选Mysql，见仁见智，首先Mysql是开源的，就好像SAS和R一样（你买得起吗你就学SAS？你的公司买SAS了吗你就学？。。。开源万岁！）。其次，Mysql的使用非常广泛，一些知名企业也使用Mysql来管理自己的数据，它执行快且容易安装和使用。 DBMS可分为两类：一种是共享文件系统的DBMS，一种是基于客户机-服务器的DBMS。前者用于桌面用途，通常不用于高端应用。Mysql即是基于客户机-服务器的DBMS。服务器是负责所有数据访问和处理的一个软件，这个软件运行在称为数据库服务器的计算机上，关于数据添加、删除、更新等请求都由服务器软件来完成。而这些请求来自于运行客户机软件的计算机，它直接和用户交互。比如，你请求检索某数据库中某张表的一个字段，则客户机软件通过网络提交请求给服务器软件，服务器软件处理这个请求并将结果反馈至客户机。（注意：客户机和服务器软件可以安装在不同或同一台计算机上，但要和数据库交互，客户机都要和服务器进行通信。） 服务器软件为Mysql DBMS。可以在本地安装的副本上运行，也可以连接到运行在你具有访问权限的远程服务器上的副本。 客户机软件是Mysql提供的工具，如Workbench等。 本菜鸟目前用的是mysql命令行实用程序以及Workbench。前者没有下拉菜单，用户界面及鼠标支持，但它是Mysql核心安装的一部分，简单实用，只需在操作系统命令提示符下输入简单语句即可进入。至于类似Workbench这类图形交互客户机软件有很多，不同人根据自己习惯喜好不同可自行选择，由于我也只用过Workbench就不瞎推荐了。。。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一首令人窒息的诗歌]]></title>
    <url>%2F2017%2F11%2F07%2Fpoetry%2F</url>
    <content type="text"><![CDATA[短歌行曹操对酒当歌，人生几何！譬如朝露，去日苦多。慨当以慷，忧思难忘。何以解忧？唯有杜康。 青青子衿，悠悠我心。但为君故，沉吟至今。 呦呦鹿鸣，食野之苹。我有嘉宾，鼓瑟吹笙。 明明如月，何时可掇？忧从中来，不可断绝。 越陌度阡，枉用相存。契阔谈讌，心念旧恩。 月明星稀，乌鹊南飞。绕树三匝，何枝可依？ 山不厌高，海不厌深。周公吐哺，天下归心。 《短歌行》是汉乐府的旧题，属于《相和歌辞·平调曲》。这就是说它本来是一个乐曲的名称。最初的古辞已经失传。乐府里收集的同名有24首，最早的是曹操的这首。这种乐曲怎么唱法，现在当然是不知道了。但乐府《相和歌·平调曲》中除了《短歌行》还有《长歌行》，唐代吴兢《乐府古题要解》引证古诗“长歌正激烈”，魏文帝曹丕《燕歌行》“短歌微吟不能长”和晋代傅玄《艳歌行》“咄来长歌续短歌”等句，认为“长歌”、“短歌”是指“歌声有长短”。现在也就只能根据这一点点材料来理解《短歌行》的音乐特点。《短歌行》这个乐曲，原来当然也有相应的歌辞，就是“乐府古辞”，但这古辞已经失传了。现在所能见到的最早的《短歌行》就是曹操所作的拟乐府《短歌行》。所谓“拟乐府”就是运用乐府旧曲来补作新词，曹操传世的《短歌行》共有两首，这里要介绍的是其中的第一首。 这首《短歌行》的主题非常明确，就是作者希望有大量人才来为自己所用。曹操在其政治活动中，为了扩大他在庶族地主中的统治基础，打击反动的世袭豪强势力，曾大力强调“唯才是举”，为此而先后发布了“求贤令”、“举士令”、“求逸才令”等；而《短歌行》实际上就是一曲“求贤歌”、又正因为运用了诗歌的形式，含有丰富的抒情成分，所以就能起到独特的感染作用，有力地宣传了他所坚持的主张，配合了他所颁发的政令。正像曹操的其它诗作如《蒿里行》、《对酒》、《苦寒行》等一样，是政治性很强的诗作，主要是为曹操当时所实行的政治路线和政治策略服务的；然而它那政治内容和意义却完全熔铸在浓郁的抒情意境之中，全诗充分发挥了诗歌创作的特长，准确而巧妙地运用了比兴手法，来达到寓理于情，以情感人的目的。在曹操的时代，他就已经能够按照抒情诗的特殊规律来取得预期的社会效果，这一创作经验显然是值得借鉴的。同时因为曹操在当时强调“唯才是举”有一定的进步意义，所以他对“求贤”这一主题所作的高度艺术化的表现，也应得到历史的肯定。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>poetry</tag>
      </tags>
  </entry>
</search>
